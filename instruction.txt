
## دستورالعمل پیاده‌سازی ماژول ai_player برای بازی تخته نرد

هدف این ماژول، ایجاد یک تابع به نام choose_move است که با دریافت وضعیت فعلی بازی و لیست حرکات ممکن، بهترین حرکت را از دید هوش مصنوعی انتخاب و برگرداند.

-------------------------------------------------------------------

### نحوه دریافت داده‌ها و تابع ورودی

زمانی که نوبت بازی به بازیکنی می‌رسد که توسط هوش مصنوعی کنترل می‌شود، اسکریپت اصلی شبکه (p2p_backgammon_network.py) تابعی را از ماژول ai_player فراخوانی می‌کند. شما باید این تابع را در ماژول ai_player.py خود ایجاد کنید.

تابع مورد انتظار در ai_player.py:

python
def choose_move(game_state, player_id, possible_moves):
    # منطق هوش مصنوعی شما برای انتخاب حرکت در اینجا قرار می‌گیرد
    # ...
    # در نهایت، یک حرکت از لیست possible_moves یا یک لیست خالی برگردانید
    pass

پارامترهای ورودی تابع choose_move:

1.  game_state (دیکشنری):
    این پارامتر یک دیکشنری حاوی تمام اطلاعات وضعیت فعلی بازی است که از تابع game_instance.get_state() در ماژول game_logic.py به دست می‌آید. ساختار آن به شکل زیر است:

    python
    {
        "board": list,          # وضعیت مهره‌ها روی ۲۴ خانه تخته.
                                # لیستی از لیست‌ها: [[owner, count], [owner, count], ...]
                                # owner می‌تواند PLAYER_X (0)، PLAYER_O (1) یا None باشد.
                                # count تعداد مهره‌ها در آن خانه است.
        "bar": dict,            # وضعیت مهره‌های خورده شده (بار).
                                # {PLAYER_X: count, PLAYER_O: count}
        "borne_off": dict,      # وضعیت مهره‌های خارج شده از بازی.
                                # {PLAYER_X: count, PLAYER_O: count}
        "current_player": int,  # شناسه بازیکنی که نوبت اوست (همان player_id شما خواهد بود).
        "dice": list,           # لیست تاس‌های ریخته شده برای نوبت فعلی، مثلا [6, 3].
                                # اگر تاس‌ها جفت باشند (مثلا [5,5])، در game_logic به صورت چهار تاس در نظر گرفته می‌شوند.
        "dice_used": dict,      # دیکشنری برای پیگیری تاس‌های استفاده شده.
                                # برای تاس‌های غیر جفت: {die_value: bool}
                                # برای تاس‌های جفت: {die_value: [bool, bool, bool, bool]}
        "winner": int or None,  # شناسه بازیکن برنده یا None اگر بازی ادامه دارد.
        "first_roll_made": bool # آیا تاس اولیه برای شروع بازی ریخته شده است یا خیر.
    }

2.  player_id (عدد صحیح):
    این پارامتر شناسه بازیکن هوش مصنوعی است (PLAYER_X که معادل 0 است یا PLAYER_O که معادل 1 است). شما باید حرکات را برای این بازیکن انتخاب کنید.

3.  possible_moves (لیستی از لیست‌ها):
    این پارامتر حیاتی، لیستی از تمام دنباله‌های حرکتی معتبری است که هوش مصنوعی می‌تواند در این نوبت با تاس‌های فعلی انجام دهد. این لیست توسط تابع game_instance.get_possible_moves() تولید می‌شود.

      ساختار: [sequence1, sequence2, ...]
      هر sequence خود یک لیست از حرکات تکی است: [(start1, end1), (start2, end2), ...]
      هر حرکت تکی (start, end) یک تاپل است:
          start: نقطه شروع حرکت. می‌تواند یک عدد (0-23) یا رشته 'BAR' باشد.
          end: نقطه مقصد حرکت. می‌تواند یک عدد (0-23) یا رشته 'OFF' باشد.
      مثال برای possible_moves:
        python
        [
            [(23, 17), (17, 14)],  # یک دنباله حرکت با دو حرکت تکی
            [(5, 'OFF')]           # یک دنباله حرکت دیگر با یک حرکت تکی (بیرون بردن مهره)
        ]
        اگر هیچ حرکتی با تاس‌های فعلی ممکن نباشد، possible_moves یک لیست خالی [] خواهد بود.

-----------------------------------------------------------------------------------------------------

 نحوه ارسال داده‌ها (خروجی تابع)

تابع choose_move شما باید یکی از دنباله‌های حرکتی موجود در لیست possible_moves را انتخاب و برگرداند.

فرمت خروجی مورد انتظار:

  یک لیست از تاپل‌های حرکت (دقیقا مشابه یکی از آیتم‌های داخل possible_moves).
      مثال: [(23, 17), (17, 14)]
  اگر possible_moves خالی باشد (هیچ حرکتی ممکن نیست)، یا اگر هوش مصنوعی شما تصمیم به پاس دادن یا انجام ندادن حرکت می‌گیرد (در صورتی که حرکتی ممکن باشد اما AI ترجیح دهد بازی نکند، که البته طبق قوانین تخته نرد اگر حرکتی ممکن باشد باید انجام شود)، تابع شما باید یک لیست خالی [] برگرداند.

نحوه استفاده از خروجی شما:

اسکریپت p2p_backgammon_network.py خروجی تابع choose_move شما را دریافت می‌کند.

1.  ابتدا بررسی می‌کند که آیا حرکت برگردانده شده توسط AI معتبر است (یعنی یکی از حرکات موجود در possible_moves اولیه بوده یا یک لیست خالی است).
2.  سپس، اگر معتبر باشد، این دنباله حرکت برای اعمال در وضعیت بازی محلی (game_instance.apply_moves) و همچنین برای ارسال به حریف از طریق شبکه استفاده می‌شود.

نکته مهم: مسئولیت انتخاب یک دنباله حرکت کامل و معتبر از لیست possible_moves بر عهده منطق هوش مصنوعی شماست. تابع شما نباید حرکتی خارج از لیست possible_moves یا با فرمت نادرست برگرداند.